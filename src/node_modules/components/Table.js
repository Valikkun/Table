import React, {Component} from 'react'
import {connect} from 'react-redux'
import {fetchTable, sort, search, select, loadPage, fetchBigTable} from 'actions'
import {getTable} from 'selectors'
import R from 'ramda'

class Table extends Component {

	state = {
		value: '',
	}

	componentDidMount() {
		this.props.fetchTable()
	}

	renderSidebar() {
		const {selectTr} = this.props
		return (
			<div className='main-form'>
				<form  onSubmit={this.handleSubmit.bind(this)}>
					<div className='form-group'>
						<input type='text' 
							   className='form-control'
							   onChange={(e) => this.setState({value: e.target.value})}
							   />
						<button type="submit" 
								className="btn btn-outline-dark "
							   >
							   	Найти
						</button>
					</div>
				</form>
				{selectTr && <div>
					<p>Выбран пользователь <b>{selectTr.firstName + ' ' + selectTr.lastName}</b></p>
					<p>Описание:</p>
					<textarea defaultValue={selectTr.description}>
					</textarea>
					<p>Адрес проживания: <b>{selectTr.address.streetAddress}</b></p>
					<p>Город: <b>{selectTr.address.city}</b></p>
					<p>Провинция/штат: <b>{selectTr.address.state}</b></p>
					<p>Индекс: <b>{selectTr.address.zip}</b></p>
				</div>}
			</div>
		)
	}

	renderTable() {
		const {sortedId, isReverse, fetching, table, sort} = this.props
		const ths = ['id', 'firstName', 'lastName', 'email', 'phone']
		return (
			<table className='table table-hover'>
				<thead>
					<tr>
						{ths.map((th, index) => 
							<th key={index}>
								<button className={sortedId === th ? 'btn btn-primary ' : 'btn btn-outline-primary '}  
										onClick={() => sort(th)}
									   >	
										{isReverse && sortedId === th ? th + ' ↓' : th + ' ↑'}
								</button>
							</th>
						)}
					</tr>
				</thead>
				<tbody>
					{!fetching && table.map((tr, index) =>
						<tr key={index} 
							onClick={()=>this.props.select(tr)}
							className={this.props.selectTr === tr ? 'tr selected' : 'tr'}
						   >
							{ths.map((td, index) => 
								<td key={index}>{tr[td]}</td>
							)}
						</tr>
					)}
				</tbody>
			</table>
		)
	}

	renderButtons() {
		const {tableIds, activePage, loadPage, fetchBigTable, fetchTable} = this.props
		const pages = []
		for (let i = 1; i<=Math.ceil(R.length(tableIds)/50); i++) {
			pages.push(i)
		}
		return (
			<div>
				<button className='btn btn-warning load-button' onClick={fetchBigTable}>Загрузить много данных</button>
				<button className='btn btn-info  load-button' onClick={fetchTable}>Загрузить мало данных</button>
				<ul className='list-inline'>
					{pages.map((page, index)=>
						<li key={index} 
							className='list-inline-item'>
								<button className={activePage === page ? 'btn btn-secondary  page-button' : 'btn btn-outline-secondary  page-button'}
										onClick={()=>loadPage(page)}
									   >	
										{page}
								</button>
						</li>)}
				</ul>
			</div>
		)
	}

	render() {
		const {fetching, fetchFailure} = this.props
		return (
			<div className='container'>
				<div className='row'>
					{this.renderSidebar()} 
					<div className='col-md-11 offset-md-1 '>
						{this.renderButtons()}
						{this.renderTable()}
						{fetching && <div className='preloader'></div>}
						{fetchFailure && <div className='failure-text'>Сорян данных нет</div>}
					</div>
				</div>
			</div>
		)
	}

	handleSubmit(event) {
    	event.preventDefault();
    	this.props.search(this.state.value)
  	}
}

const mapStateToProps = state => ({
	table: getTable(state),
	tableIds: state.tablePage.ids,
	fetchFailure: state.table.failure,
	sortedId: state.tablePage.sort,
	isReverse: state.tablePage.reverse,
	selectTr: state.tablePage.select,
	fetching: state.tablePage.fetching,
	activePage: state.tablePage.page,
})

const mapDispatchToProps = {
	fetchTable,
	fetchBigTable,
	sort,
	search,
	select,
	loadPage,
}

export default connect(mapStateToProps, mapDispatchToProps)(Table)